# Signatures

Some understanding of elliptic curve cryptography will help in understanding this code.
I highly recommend reading the ["Elliptic Curve Cryptography: a gentle introduction"][intro] series
(at least the three first articles).

[intro]: https://andrea.corbellini.name/2015/05/17/elliptic-curve-cryptography-a-gentle-introduction/

For clarity, we have rebundled curves parameters in the `Curve` class. In particular, we define:

- `q`, the order (size) of the finite field on which the curve is defined. Sometimes this is also
  called `p` (as in the article). `p` is used only for prime fields (which we use exclusively),
  while `q` is used for both prime fields and `2^m` fields. 
- `n`, the order (size) of the cyclic subgroup generated by `G`.
- `G`, a point of the curve generating a cyclic subgroup of the field, of order `n`.

Additionally, the following documents specify the behaviour of various algorithms & curves used: 
- [SEC1: Elliptic Curve Cryptography](https://www.secg.org/sec1-v2.pdf) (pdf)
- [SEC2: Recommended Elliptic Curve Domain Parameter](http://www.secg.org/sec2-v2.pdf) (pdf)
- [ECDSA: The Elliptic Curve Digital Signature Algorithm](https://www.cs.miami.edu/home/burt/learning/Csc609.142/ecdsa-cert.pdf) (pdf) 
- [IETF RFC 6979: Deterministic Usage of the Digital Signature Algorithm (DSA) and Elliptic Curve Digital Signature Algorithm (ECDSA)](https://datatracker.ietf.org/doc/html/rfc6979)

SEC2 includes the parameter the secp256k1 used for signatured in Ethereum. SEC1 notably explains how
to serialize curve points to byte arrays, include the compressed form. SEC1 and the ECDSA document
have a lot of overlap. ECDSA is in fact "standardized" in a slew of documents, of which SEC1 is one
of the most restrictive (see section 10 of the ECDSA document for more details).

RFC 6979 discussed how the signature secret (`k`) can be derived deterministically using HMAC
instead of picked randomly. See discussion in the "Selecting `k`" section below.
    
## Signature Verification & Recovery IDs (`v`)

An important point to understand the code is that **the same `(r, s)` signature could have been
generated from up to four different private keys.**

Recall the private key is an integer `d` in `[1, n-1]` and the associated public key is `P = dG`, 
an elliptic curve point.

`r` is defined as `r = P.x mod n`, where `P = kG` and `k` is the signature's secret. Since `r`
derives from `P.x` but not `P.y`, for any valid `x`, both `(x, y)` and `(x, -y)` are valid `P`
points (in this context, `-y = q - y`). This is due to the fact that elliptic curves are symmetric
(with a horizontal axis of symmetry around `y = q/2`).

Additionally, `r` elliptic curve points coordinate are finite field elements (`< q`) but `r` is
computed `mod n`. So whever `n < x + n < q`, both `x` and `x + n` could have yielded the same `r`
value.

So, for a given `r`, the four elliptic curve points `(x, y)`, `(x, -y)`, `(x + n, y)` and `(x + n,
-y)` are potential `P` points. The first two are always possible, while the later two are very rare
because the probability of `n <= x + n < q` is exceedingly small (< 1/10^36). It's so rare that
Ethereum decides to not consider them, see below.

There are two equivalent ways of verifying a signature. The first one involves reconstructing `P` using
`(r, s)` and the public key (an elliptic curve point `Q`). The second one is to recover the public
key `Q` from `(r, s)` and check that against the public key whose signature we want to verify.
Ethereum clients tend to use this second way because an address is composed of the 160 rightmost
bits of the public key. So to verify a signature, we just recover the public key and compare its 160
rightmost bits to the sender's address.

However, because multiple `P` are possible, multiple `Q` are also possible. We either need to check
the four possible keys, or be given a specific recovery ID (sometimes written `recId`) to tell us
which key to recover.

To verify a signature, we recover the public key that would have generated the signature from the
signature, then compare that it conforms to the public key we want to check. However, because
multiple public keys are possible, we either need to the check the four possible keys, or to be
given a specific recovery ID (sometimes written `recId`) to tell us which `P` point is the correct
one, and consequently, which public key to recover.

The recovery ID has a value in `[0, 3]`:
- 0 = `(x < n,  even y)`
- 1 = `(x < n,  odd  y)`
- 2 = `(x >= n, even y)`
- 3 = `(x >= n, odd  y)`

Notice that instead of `y` and `-y` we now say `even y` or `odd y`. This is because since `q` is and
odd prime, if `y` is even, then `-y` is necessary odd, and vice versa. Speaking of `y` and `-y`
would be problematic, because which one is the "real" `y`? We could settle on `y < q/2` being the
"real" `y`, but ultimately it's easier to compute eveness through `mod 2`.

For similar reasons, we use `x < n` and `x >= n` instead of `x` and `x + n`.  As we said, Ethereum
disallows the `x >= n` case altogether. In the yellowpaper this difference is called "finitess", `x
< n` being "finite".

What would happen if by extreme lack of luck we were to generate a `x >= n` signature for a
transaction? Assuming the wallet or contract does not crash, the signature would be rejected, and
the transaction wouldn't go through. Changing any detail about the transaction (e.g. adding one wei
to the transferred amount) would solve the issue. Another solution would be for the wallet/contract
to retry with a different (random) `k` value — I doubt any do this, as a deterministic algorithm for
`k` is typicaly used (see below). I've implemented it here however.

A signed transaction has an additional value `v`. This can be defined as either:
- 27 + the recovery ID
- 35 + 2 * the chain ID + the recovery ID

Since Ethereum's mainnet chain ID is 1, that makes the common values 27, 28, 37 and 38 (beware that
testnets have different chain IDs).

The 27-based version is the legacy version. Why is 27 added? I couldn't find an explanation,
excepted that it was copied from Bitcoin.

The 35-based version was [added] because transactions from Ethereum could be [replayed] on Ethereum
Classic (a fork of Ethereum where the DAO theft was not reversed). By adding a chain ID and signing
it along with the transaction, transactions can no longer be replayed cross-chain.

[added]: https://github.com/ethereum/EIPs/blob/master/EIPS/eip-155.md
[replayed]: https://en.wikipedia.org/wiki/Replay_attack

These days clients should sign transactions using the 35-based protocol, and should probably
reject new transactions using the 27-based protocol (though they should be able to process
historical transactions). These transactions are [not yet][geth110] rejected however.

[geth110]: https://blog.ethereum.org/2021/03/03/geth-v1-10-0/

## Signature Canonicalization

For every signature `(r,s)` the signature `(r, -s (mod n))` is a valid signature of the same
message (1). It is undesirable to be able to have two identical signed transactions with different
signatures, which is a limited form of [malleability]. In particular, bad things can happen when a
signature is used as a unique identifier for the purpose of replay protection (e.g. [Bitcoin
malleability attack][bit-mal]). Therefore, `s` values higher than half of the subgroup's order
(`n/2`) are canonicalized to their modular complement `-s = n - s (mod n)`.

(1) Proving this is outside the scope of this document, but if you want to be convinced, try playing
with the equation in the "Correctness of the algorithm" section in [this article][ecdsa-intro].

This was added in [EIP-2]. The `ECDSARECOVER` precompiled contract still accepts values of `s >
n/2`, which allows recovering old Ethereum/Bitcoin signatures.

[malleability]: https://en.wikipedia.org/wiki/Malleability_(cryptography)
[bit-mal]: https://eklitzke.org/bitcoin-transaction-malleability
[ecdsa-intro]: https://andrea.corbellini.name/2015/05/30/elliptic-curve-cryptography-ecdh-and-ecdsa/
[EIP-2]: https://github.com/ethereum/EIPs/blob/master/EIPS/eip-2.md

## Point Compact Representation

An elliptic curve point on secp256k1 can be encoded uncompressed as its `(x, y)` coordinates, both
of which can be encoded on 256 bits = 64B. However, since `y` depends on `x` through the curve's
equation, the representation can be compressed.

Since elliptic curve have an x-axis symmetry, there are two possible `y` value for each `x` value.
Since the finite field `p` is an odd prime, one of these values will be even, and one will be odd.
A point can thus be encoded on 65B: 64B for the `x` value, and an extra byte that encodes whether
the `y` value is even or odd.

All of this is specified in a few standards, notably in SEC1 §2.3.3 and §2.3.4.

In fact, the standard also adds a header byte in front of the uncompressed representation, which
simply signifies that the representation is uncompressed.

Possible header bytes are:
- 0x00 — the `0` curve point
- 0x02 — compressed with even `y`
- 0x03 — compressed with odd `y`
- 0x04 — uncompressed

I've seen at least one implementation stripping the header byte and storing only some point
uncompressed, but I haven't gotten to the point where I needed this, so I don't know if this is an
implementation choice, or a consequence of some Ethereum requirement.

Note there are some issue with the compression scheme (most notably it breaks power-of-2) alignment.
Here's [proposed replacement].

[proposed replacement]: https://tools.ietf.org/id/draft-jivsov-ecc-compact-05.html#rfc.section.3

## Signature: Selecting Nonces (`k`)

When generating a signature, a signature secret or "nonce" `k` in [1, n-1] must be selected. `k` can
be selected randomly, or deterministically from the message being signed, for instance by using a
hash function. The nonce must be kept secret and not reused, otherwise the private key [can be
recovered][key-recovery].

[key-recovery]: https://github.com/tintinweb/ecdsa-private-key-recovery

Ethereum and other blockchain clients typically compute `k` using HMAC over the message, as proposed
in IETF RFC6979 §3.2. The arguments in favour of HMAC are (1) signature determinism and (2) avoiding
potential issues when the randomness source has insufficient entropy and could be
reverse-engineered.

The downside of using the deterministic scheme is [sensitivity to fault attacks][faults] — which
involve provoking faults in the hardware or software to move the implementation to an unexpected
state. However, those are difficult to pull off, as they require advanced access to your hardware or
software.

The other downside of using the deterministic scheme was discussed above: in extremely rare cases
the generated signature will be rejected by Ethereum.  In nanoeth, we use the HMAC scheme by default
and fallback to random `k` if we ever encounter a rejected signature.

[faults]: https://crypto.stackexchange.com/questions/50228

Please note that when using multisignatures, `k` values **must be** picked randomly, or your
co-signers wil be able to guess your private key.

TODO inverse vs complement